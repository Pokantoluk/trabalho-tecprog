#pragma once
#include <iostream>

namespace Game
{
    namespace Lista
    {
        template <class TL>
        class Lista 
        {
        private:
            /* template Elemento para usar como node da lista */
            template <class TE>
            class Elemento 
            {
            private:
                Elemento<TE>* prox;
                TE* info;

            public:
                Elemento() 
                {
                    prox = nullptr;
                    info = nullptr;
                }
                ~Elemento() 
                {
                    prox = nullptr;
                    info = nullptr;
                }
                void set_next(Elemento<TE>* prox) { this->prox = prox; }
                void set_info(TE* info) { this->info = info; }
                Elemento<TE>* get_next() { return prox; }
                TE* get_info() { return info; }
            };

            Elemento<TL>* primeiro;
            Elemento<TL>* ultimo;
            unsigned int tam;

        public:
            Lista();
            ~Lista();

            void destruir();
            unsigned int get_tam() { return tam; }
            TL* operator[](int x);
            void inserir(TL* info);
            TL* retirar(TL* info);
            TL* retirar(int index);

        private:
            void set_elemento(Elemento<TL>* elemento);
            Elemento<TL>* get_primeiro() { return primeiro; }
            Elemento<TL>* get_ultimo() { return ultimo; }
        };

        template <class TL>
        Lista<TL>::Lista() :
            primeiro(nullptr),
            ultimo(nullptr),
            tam(0)
        {
        }

        template <class TL>
        Lista<TL>::~Lista() { }

        template <class TL>
        void Lista<TL>::destruir() 
        {
            Elemento<TL>* aux1;
            Elemento<TL>* aux2;

            aux1 = primeiro;
            aux2 = aux1;
            int i = 0;

            while (aux1 != nullptr && i < tam) 
            {
                delete (aux1->get_info());
                aux2 = aux1->get_next();
                delete (aux1);
                aux1 = aux2;
                i++;
            }

            primeiro = nullptr;
            ultimo = nullptr;
            tam = 0;
        }

        template <class TL>
        void Lista<TL>::set_elemento(Elemento<TL>* elemento) 
        {
            if (elemento != nullptr) 
            {
                if (primeiro == nullptr) 
                {
                    primeiro = elemento;
                    ultimo = elemento;
                }
                else 
                {
                    ultimo->set_next(elemento);
                    ultimo = elemento;
                }
                tam++;

            }
            else 
            {
                std::cout << "Erro no set_elemento. Elemento == nullptr." << std::endl;
            }
        }

        /* Retorna o objeto que o index aponta*/
        template <class TL>
        TL* Lista<TL>::operator[](int index) 
        {
            if (index >= tam || index < 0) 
            {
                std::cout << "ERRO: Seg fault na lista. Procurou fora da lista." << std::endl;
                exit(1);
            }

            Elemento<TL>* aux = primeiro;
            for (int i = 0; i < index; i++) 
            {
                aux = aux->get_next();
            }

            if (aux == nullptr) 
            {
                std::cout << "Erro no operator[] aux == nullptr." << std::endl;
                exit(1);
            }
            return aux->get_info();
        }

        /* insere um elemento na lista */
        template <class TL>
        void Lista<TL>::inserir(TL* info) 
        {
            if (info != nullptr) 
            {
                Elemento<TL>* elemento = nullptr;
                elemento = new Elemento<TL>();
                elemento->set_info(info);
                set_elemento(elemento);
            }

            else 
            {
                std::cout << "Erro no inserir da lista. info == nullptr" << std::endl;
            }
        }

        /* Remove o elemento especificado.*/
        template <class TL>
        TL* Lista<TL>::retirar(TL* info) 
        {
            Elemento<TL>* aux = primeiro;
            Elemento<TL>* anterior = nullptr;
            while (aux != nullptr) 
            {
                if (aux->get_info() == info) 
                {
                    if (aux == primeiro) 
                    {
                        primeiro = aux->get_next();
                    } //
                    else if (aux == ultimo) 
                    {
                        ultimo = anterior;
                        anterior->set_next(nullptr);
                    } //
                    else 
                    {
                        anterior->set_next(aux->get_next());
                    }

                    delete (aux);
                    tam--;
                    return info;
                }

                anterior = aux;
                aux = aux->get_next();
            }
            return nullptr;
        }

        /* Remove o elemento do index da lista dele e o retorna*/
        template <class TL>
        TL* Lista<TL>::retirar(int index) 
        {
            if (index >= tam || index < 0) 
            {
                std::cout << "ERRO: Seg fault na lista(retirar). Procurou fora da lista. Index: " << index << " de " << tam << " elementps." << std::endl;
                exit(1);
            }

            Elemento<TL>* aux = primeiro;
            Elemento<TL>* anterior = nullptr;

            for (int i = 0; i < index; i++) 
            {
                anterior = aux;
                aux = aux->get_next();
            }

            if (aux == primeiro) 
{
                primeiro = aux->get_next();
            } //
            else if (aux == ultimo) 
{
                ultimo = anterior;
                anterior->set_next(nullptr);
            } //
            else 
{
                anterior->set_next(aux->get_next());
            }

            TL* info = aux->get_info();

            delete (aux);
            tam--;

            return info;
        }

    }
}